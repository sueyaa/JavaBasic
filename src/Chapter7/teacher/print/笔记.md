#目标:

1. 方法的重写
2. 多态
3. 关键字final
4. 作用域以及执行顺序.

##方法的重写

学习方法重写之前大家要回顾3个概念:

1. 方法:独立可以被复用的代码块.用来体现类所描述的事物的行为
2. 重载:指一个类中方法同名但是参数列表不同.
3. 继承:概念来自现实生活.要满足is-a关系.才可以使用继承.在代码中使用关键字extends. class A extends B 代表A继承B

###方法的声明格式
访问修饰符 返回值 方法名称(参数列表){方法体}

方法名称和参数列表构成方法的签名.签名用于确定方法的唯一性.

###重载的形式:
1. 有参和无参(数量不一样)
2. 参数个数一样但是参数类型不一样
3. 数量相同类型一致(数量和类型要>2)顺序不一致

方法是体现行为的.重载可以理解为同一种行为(因为方法名称没有改变)针对不同的数据来源(参数列表不同).有不同的实现方式(方法体不一样)

最常见的方法重载:构造方法的重载

###构造方法以及重载
每个类JVM都会默认提供一个无参构造,该无参构造是隐藏的.当人为的提供任何一个构造方法是(无论是有参还是无参)都会替换掉系统提供的无参构造.

构造方法:没有返回值,方法名称和类名一致的特殊方法.只能被new调用.用于构造对象.(是构造对象常用的方式,但不是唯一的方式.)

###继承:
继承体现在父子类上.父类和子类满足is-a关系.即猫is-a宠物(同一物种).我们不能说飞机继承鸟.当继承成立子类默认自动拥有父类的所有非私有内容.(私有的后期学反射时可以访问).Java针对继承关系提供了3个关键字

1. this
2. super
3. extends


##方法的重写:
###概念:
在继承关系下,子类自动拥有父类的内容(非私有).即子类和父类拥有相同的行为和特征.

同样的一种行为子类和父类执行方式不一样.这种现象被叫做方法重写.代表体现为:方法声明一致但是方法体不一样.

##重载和重写的区别

###前提
重载:

1. 同一个类
2. 方法同名
3. 参数列表不同

重写

1. 在继承关系中
2. 方法声明不变,方法体改变.
3. 访问修饰符可以提高不可以降低.可以由默认提供到public.但是反过来不行(该条件是额外的.)

都是针对同一种行为的不同的体现.

当子类继承父类时,如果子类没有重写父类的方法.当子类调用继承得到的方法时,实际执行的就是父类中的方法.如果子类重写类父类的方法.那么执行的就是子类中重写过的方法的.

##多态:
从字面上来理解多态就是多种形态.(类型).JVM在运行时会为每个对象记录一个运行时类型.该类型决定了这个对象可以执行哪些方法和字段.Java使用多态来实现在运行时决定具体的对象.语法格式:以父类为类型创建子类对象.

多态的优缺点:

1. 优点:灵活.范围上概念比较广

2. 缺点:因为运行时类型决定了最终对象可以调用的方法和字段.所以为类型 以父类所创建的子类对象能够使用的方法只能是父类和子类都共有的(只能是父类声明过的.子类特有的无法使用.)

    class A{
    	public void method1(){
    	}
    }
    
    class B extends A{
    	public void method2(){//--自己特有的
    	}
    }
    
    A a = new A();
    a.method1()
    
    B b = new B();
    b.method1();
    b.method2();
    
    A b1 = new B();
    A 是运行时类型
    new B(); 是具体的对象.
    b1.XX执行的是new B()中的方法.但是因为运行时类型是A不是B所以b1无法使用B中特有的内容.只能使用A中声明过的内容.


在多态中.按照继承的基本原则子类对象可以看做是父类对象.同理父类对象在某些情况下有可以看做是子类对象.这就涉及转型

1. 向上转型.子类转父类 小转大.隐式
2. 向下转型.父类转子类 大转小.强制.需要做类型验证.使用instanceof关键字来验证类型是否匹配.如果不验证会产生ClassCastException.类型转换异常.

##final关键字
final代表最终.不可以被修改的,不会再发生改变的.final在代码中是属于修饰词用来修饰:

1. 变量
	1. 原生类型  final int i = 10; 即i不可以被再次赋值.
	2. 引用类型  final Student stu = new Student(); 即引用变量不可以指向其它的对象.对象字段的值的改变没有影响.
2. 方法
	1. 普通方法
		1. final修饰的方法被重载
    public final void method(){
    		
    }
    	
    public final void method(int i){
    		
    } 
		2. final修饰的方法不可以被重写.
	2. 构造方法:构造方法的修饰符只能是public,protected,private 
3. 类 final修饰类,该类不可以被继承.



##常见面试题:
1. String 可以被被继承吗 ?
答:String是被final修饰的,因此不可以被继承.



##课堂练习:
1. 重写
设计英雄类(Hero)在该类中定义4个方法.(对应英雄的4个技能.).定义具体的3个英雄.分别重写这4个方法.(盖伦,皇子,菊花.)

2. 继承.封装.多态. 
培训中心有打印机,打印机个可以打印老师的教案和学生的简历.打印机有针式,激光和喷墨.中心有北上广三家中心.

寻找名词:
培训中心,打印机,教案,简历,针式,激光,喷墨,北上广

确定要建立的类.
1. 培训中心和北上广. 培训中心中应该定义培训中心所通有的内容.北上广可以是培训中心的3个对象(没有特性的时候)或者3个子类.(有自己特性的时候选择使用3个子类)

2. 打印机和激光,针式,喷墨.三款打印机都有打印的行为.这个时候就要考虑是否需要抽取父类.如果要抽取.那么父类中要定义哪些内容.针对目前需求.三款所共同具备的行为.是打印如果不抽取父类.就需要在3个类各写一遍.这样会造成代码重复.选择父类.并在父类中提供共有的行为:打印行为.因为不同的打印机打印方式不一样所以要使用子类.

3. 教案和简历都属于文档.因此抽取共性构建文档类.
当遇到多个类(前提是同一类事物)有共性时要抽取共性内容组建父类.

当类确定以后开始确定类和类之间的关系:
常见的关系有:
is-a 继承  : 继承
has-a 拥有 : 成员变量
use-a 使用 : 局部变量或者方法参数

除了以上三种还有like-a
翻译成中文:
继承(泛化) 实现(接口) 关联 组合 聚合 依赖


分析:
1. 针式,激光,喷墨和打印机是什么关系
2. 北上广和培训中心是什么关系
3. 培训中心和打印机是什么关系
4. 打印机和教案,简历是什么关系.

针式有针式的打印方式.喷墨有喷墨的打印方式.激光有激光的打印方式.针式.激光和喷墨应该是继承打印机的3个子类.且3款打印机都有打印这一行为(只是不同的打印机有不同的是实现方式).父类中有打印方法.

如果北上广没有自己特有的内容.我们使用3个对象分别代表北上广是否可以.如果添加地方特色功能需要给3个类.相反如果没有特色功能都不和培训中心一样.那么使用三个对象分别赋值不同的地方就可以了.

培训中心有打印机.怎么有.到超市买回来安装.在代码中体现为在培训中心这个类中.添加打印机作为其成员变量.

打印机所打印的内容不是打印机内部自动生成的是由外部传入的.即文档是要传给打印机.如果把打印当做一种行为.行为使用方法.我们怎么给方法传递内容.使用参数.即文档要作为打印这个方法的参数.



#预习:
1. 抽象类.
2. 接口.
3. 抽象类和接口的区别.
4. 什么情况下使用接口.
5. OO五大原则.
6. 继承(泛化) 实现(接口) 关联 组合 聚合 依赖 .类和类之间的关系.


#扩展
1. 部分编译器会有绿色向下箭头.什么情况会产生该现象.



